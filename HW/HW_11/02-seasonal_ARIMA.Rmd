# (10 points) Seasonal ARIMA model

```{r data download, results='hide'}
library(fredr)
if (fredr_has_key()){
  ecom_df <- fredr(series_id = "ECOMPCTNSA",
  observation_start = as.Date("1990-01-01"))
  ecom_df <- cbind.data.frame(ecom_df[c(1,3)], index = 1:nrow(ecom_df))
  ecom_ts <- as_tsibble(ecom_df, index = "date")
} else {
  print("Expect FREDR API key as an environment variable")
  quit(save="ask")
}
```

```{r train/test split}
split <- as.Date("2020-12-31")
train_ts <- ecom_ts %>% filter(date < split)
test_ts <- ecom_ts %>% filter(date >= split)
```
Download the series of E-Commerce Retail Sales as a Percent of Total Sales [here](https://fred.stlouisfed.org/series/ECOMPCTNSA). 

(Feel free to explore the `fredr` package and API if interested.)

Our goal is to Build a Seasonal ARIMA model, following all appropriate steps for a univariate time series model.

Separate the data set into training and test data. The training data is used to estimate model parameters, and it is for 10/1999-12/2020. The test data is used to evaluate its accuracy, and it is for 01/2021-01/22.

## Time series plot

Plot training data set of Retail Sales. What do you notice? Is there any transformation necessary?

```{r time series plot, results='hide', echo = FALSE, warning=FALSE}
#Plot the original seris
ts_plot <- autoplot(train_ts) + labs(x = element_blank(), y = 'Fraction of e-comm, %')

# Calculate the trend and de-trended series
trend <- ma(train_ts$value, order = 4, centre = T)
seasonal_comp <- train_ts$value/trend 

#Generate dataframe for modeling
decomp_df <- cbind.data.frame(train_ts, trend, seasonal_comp)
names(decomp_df) = c("my_date", "value", "index", "trend", "detrended")
decomp_df <- na.omit(decomp_df)
# Fit quadratic and logarythmic models
model.quad <- lm(formula = trend ~ index + I(index^2), data = decomp_df)
model.log <- lm(formula = log(trend) ~ index, data = decomp_df)

#Make plot for the TS
trnd_plt<- ggplot(data = decomp_df) + 
  geom_line(aes(x = my_date, y = trend )) + 
  scale_y_continuous(expand = c(0,0)) + labs(x = element_blank())

#Make plot for the model residuals
res_plt<- ggplot(data = decomp_df) + 
  geom_line(aes(x = my_date, y = model.quad$residuals, color = "Quadratic")) + 
  geom_line(aes(x = my_date, y = model.log$residuals, color = "Log" )) + 
  scale_y_continuous(expand = c(0,0)) + labs(x = element_blank(), y = "Model residuals") +
  scale_color_manual(name = "Trend Models", values = c("Quadratic" = "black", 
                                           "Log" = "blue")) +
  # Legend text and position
  theme(legend.position=c(.3,.75))
# Make plot for the de-trended series
seasonal_plt <- ggplot(data = decomp_df) + aes(x = my_date, y = detrended ) + geom_line() + 
  scale_y_continuous(expand = c(0,0)) + labs(x = element_blank())

#Display plots
ts_plot/(trnd_plt|res_plt|seasonal_plt)
```

```{r residuals for quad model, results='hide', warning=FALSE}
png(file = './figures/plot1_quad_mod_resid.png', height=3, width=4, units = c("in"), res = 600)
checkresiduals(model.quad, test=FALSE, plot = TRUE)
dev.off()
```


Fraction of e-commerce in the overall retail sales is growing, and its growth is accelerating. It appears that at around the start of the COVID-19 pandemic the acceleration increased. This is evident from abrupt change in the overall trend curvature at the beginning of 2020. The series also has marked seasonal component, and the magnitude of the seasonal component is increasing, suggesting a multiplicative seasoning. The trend has obvious curvature, but neither quadratic, nor logarithmic transformation result in white-noise residuals.

## Check for Stationary 

Use ACF/PACF and a unit root test to check if Retail Sales is stationary. If data is not stationary, difference the data, and apply the
test again until it becomes stationary? How many differences are needed to make data stationary?

```{r Check for Stationary}
#Fill this in

```

> Given strong trend and seasonality in the data it is obvious that the original series is not stationary.  

## Model identification and estimation

Use ACF/PACF to identify an appropriate SARIMA model. Estimate both select model and model chosen by ARIMA()

```{r Model identification and estimation}
#Fill this in

```

> 'Fill this in

## Model diagnostic 

Do residual diagnostic checking of both models. Are the residuals white noise? Use the Ljung-box test to check if the residuals are white noise.  

```{r diagnostic}
#Fill this in

```

> 'Fill this in


## Forcasting 

Use the both models to forecast the next 12 months and evaluate the forecast accuracy of these models.

```{r forcasting}
#Fill this in

```

> 'Fill this in